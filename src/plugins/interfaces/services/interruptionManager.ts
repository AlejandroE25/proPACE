/**
 * Interruption Manager
 *
 * Tracks active response sessions per client and handles interruptions.
 * Prevents self-interruption (Pace thinking he's interrupting himself)
 * while allowing user interruptions.
 *
 * Each response gets a unique responseId that tracks:
 * - Text generation status (generating, streaming, completed, interrupted)
 * - Audio playback status
 * - Source of interruption (user vs system)
 * - AbortController for cancellation
 */

import { randomUUID } from 'crypto';

/**
 * Session status
 */
export enum SessionStatus {
  GENERATING = 'generating',    // Response being generated by Claude
  STREAMING = 'streaming',       // TTS audio being streamed
  COMPLETED = 'completed',       // Response fully delivered
  INTERRUPTED = 'interrupted'    // Interrupted by user
}

/**
 * Response session
 */
export interface ResponseSession {
  responseId: string;           // Unique response identifier
  clientId: string;             // Client this response is for
  status: SessionStatus;        // Current status
  startTime: number;            // When session started (ms)
  endTime?: number;             // When session ended (ms)
  abortController: AbortController;  // For cancellation
}

/**
 * Interruption statistics
 */
export interface InterruptionStatistics {
  totalSessions: number;
  activeSessions: number;
  completedSessions: number;
  interruptedSessions: number;
  averageSessionDuration: number;
}

/**
 * Interruption Manager
 */
export class InterruptionManager {
  private sessions: Map<string, ResponseSession>;  // clientId -> session
  private stats: {
    total: number;
    completed: number;
    interrupted: number;
    durations: number[];  // For calculating average
  };

  constructor() {
    this.sessions = new Map();
    this.stats = {
      total: 0,
      completed: 0,
      interrupted: 0,
      durations: []
    };
  }

  /**
   * Create a new response session for a client
   * Replaces any existing session for the same client
   */
  createSession(clientId: string): ResponseSession {
    // If there's an existing session, interrupt it first
    if (this.sessions.has(clientId)) {
      this.interrupt(clientId);
    }

    const session: ResponseSession = {
      responseId: randomUUID(),
      clientId,
      status: SessionStatus.GENERATING,
      startTime: Date.now(),
      abortController: new AbortController()
    };

    this.sessions.set(clientId, session);
    this.stats.total++;

    return session;
  }

  /**
   * Get current session for a client
   */
  getSession(clientId: string): ResponseSession | undefined {
    return this.sessions.get(clientId);
  }

  /**
   * Check if a specific response is still active
   */
  isActiveResponse(clientId: string, responseId: string): boolean {
    const session = this.sessions.get(clientId);

    if (!session) {
      return false;
    }

    // Session must match responseId and not be interrupted/completed
    return (
      session.responseId === responseId &&
      session.status !== SessionStatus.INTERRUPTED &&
      session.status !== SessionStatus.COMPLETED
    );
  }

  /**
   * Interrupt active session for a client
   */
  interrupt(clientId: string): void {
    const session = this.sessions.get(clientId);

    if (!session) {
      return; // No session to interrupt
    }

    // Abort any ongoing operations
    session.abortController.abort();

    // Update session status
    session.status = SessionStatus.INTERRUPTED;
    session.endTime = Date.now();

    // Track statistics
    this.stats.interrupted++;
    const duration = session.endTime - session.startTime;
    this.stats.durations.push(duration);
  }

  /**
   * Mark session as completed
   */
  completeSession(clientId: string): void {
    const session = this.sessions.get(clientId);

    if (!session) {
      return; // No session to complete
    }

    session.status = SessionStatus.COMPLETED;
    session.endTime = Date.now();

    // Track statistics
    this.stats.completed++;
    const duration = session.endTime - session.startTime;
    this.stats.durations.push(duration);
  }

  /**
   * Update session status
   */
  updateStatus(clientId: string, status: SessionStatus): void {
    const session = this.sessions.get(clientId);

    if (!session) {
      return; // No session to update
    }

    session.status = status;
  }

  /**
   * Clear session for a client
   */
  clearSession(clientId: string): void {
    this.sessions.delete(clientId);
  }

  /**
   * Get interruption statistics
   */
  getStatistics(): InterruptionStatistics {
    const activeSessions = Array.from(this.sessions.values()).filter(
      session => session.status === SessionStatus.GENERATING ||
                 session.status === SessionStatus.STREAMING
    ).length;

    const averageSessionDuration = this.stats.durations.length > 0
      ? this.stats.durations.reduce((sum, d) => sum + d, 0) / this.stats.durations.length
      : 0;

    return {
      totalSessions: this.stats.total,
      activeSessions,
      completedSessions: this.stats.completed,
      interruptedSessions: this.stats.interrupted,
      averageSessionDuration
    };
  }

  /**
   * Reset all statistics
   */
  resetStatistics(): void {
    this.stats = {
      total: 0,
      completed: 0,
      interrupted: 0,
      durations: []
    };
  }

  /**
   * Clear all sessions
   */
  clearAllSessions(): void {
    // Interrupt all active sessions
    for (const [clientId] of this.sessions) {
      this.interrupt(clientId);
    }

    this.sessions.clear();
  }
}
